
Linear Meld (LM) is a \emph{forward chaining} logic programming language in the style of Datalog~\cite{Ullman:1990:PDK:533142}. The program is defined as a \emph{database of facts} and a set of \emph{derivation rules}.
Initially, we populate the database with the program's axioms and then determine which derivation rules can be applied by using the current database. Once a rule is applied, we derive new facts, which are then added to the database.
If a rule uses linear facts, they are consumed and thus deleted from the database.
The program stops when we reach \emph{quiescence}, that is, when we can no longer
apply any derivation rule.

The database of facts can be seen as a graph data structure where each node or vertex contains a
fraction of the database.  Since derivation rules can only manipulate facts belonging to
a node, we are able to perform independent rule derivations.

Each fact is an association between a \emph{predicate} and a tuple of values. A predicate is a pair with a name and a tuple of types (the argument types).
LM rules are type-checked using the predicate declarations in the header of the program. LM has a simple type system that includes the following simples types:
\emph{node}, \emph{int}, \emph{float}, \emph{string}, \emph{bool}. Recursive types such as \emph{list X} and \emph{pair X; Y} are
also allowed.

The first argument of every predicate must be typed as a \emph{node}.
For concurrency and data partitioning purposes, derivation rules are constrained by the expressions that can be written in the body.
The body of every rule can only refer to facts in the same node.
However, the expressions in the head may refer to other nodes, as long as those nodes are instantiated in the body of the rule.
The database of the program can then be partitioned by the first argument of each fact.

Each rule in LM has a defined priority that is inferred from its position in the source file.
Rules at the beginning of the file have higher priority. At the node level, we consider all
the new facts that have been not consider before to create a set of \emph{candidate rules}.
The set of candidate rules is then applied (by priority) and updated as new facts are derived.

Our first program example is shown in Fig.~\ref{code:message}. This is a message routing program
that simulates message transmission through a network of nodes.
We first declare all the predicates (lines 1-2), which represent the kinds of facts we are going to
use. The first argument of every predicate must be typed as a \texttt{node}, which represents the location of the fact in
the graph data structure. Predicate \texttt{edge/2} is a non \texttt{linear} (persistent) predicate while \texttt{message/3} is linear.
The second argument of \texttt{message/2} is the message content represented as a \texttt{string}
while the third argument is the route list.

The program rules are declared in lines 4-8, while the program's axioms are written in lines 10-11.
When persistent facts are used in rules (line 5) they must be
preceded by \texttt{!}. This helps the programmer in distinguishing between persistent facts and linear facts.

\begin{figure}[h!]
\small\begin{Verbatim}[numbers=left]
type edge(node, node).
type linear message(node, string, list node).

message(A, Content, [B | L]),
!edge(A, B)
   -o message(B, Content, L).

message(A, Content, []) -o 1.

!edge(@1, @2). !edge(@2, @3). !edge(@3, @4). !edge(@1, @3).
message(@1, 'Hello World', [@3, @4]).
\end{Verbatim}
\caption{Message program.}
  \label{code:message}
\end{figure}

The first rule (lines 4-6) grabs the next node in the route list (third argument of \texttt{message/3}) and
ensures that a communication edge exists (through \texttt{edge(A, B)}).
A new \texttt{message(B,~Content,~L)} fact is derived at node \texttt{B}.
When the route list is empty, the message has reached its destination and thus it is consumed
(rule in lines 8-9). Note that \texttt{1} in the head of the rule means that nothing is derived.

Figure~\ref{code:visit} presents another complete LM program that, for a given graph
of nodes, performs a visit to all nodes reachable from node $@1$.
The first rule of the program (lines 6-7) is fired when a node \texttt{A} has a \texttt{visit(A)} and a \texttt{unvisited(A)} fact.
When fired, we first derive \texttt{visited(A)} to mark node \texttt{A} as \textit{visited} and use a
\emph{comprehension} to go through all the edge facts \texttt{edge(A,B)} and derive \texttt{visit(B)} for each
one (comprehensions are explained next in detail). This forces those nodes to be visited also.
The second rule (line 9) is fired when a
node \texttt{A} is already visited more than once: we keep the \texttt{visited(A)} fact and delete \texttt{visit(A)}.
Node $@1$ starts with the \texttt{visit(@1)} fact (line 13).

\begin{figure}[h!]
\small\begin{Verbatim}[numbers=left]
type edge(node, node).
type linear visit(node).
type linear unvisited(node).
type linear visited(node).

visit(A), unvisited(A) -o
   visited(A), {B | !edge(A, B) | visit(B)}.

visit(A), visited(A) -o visited(A).

!edge(@1, @2). !edge(@2, @3). !edge(@1, @4). !edge(@2, @4).
unvisited(@1). unvisited(@2). unvisited(@3). unvisited(@4).
visit(@1).
\end{Verbatim}
  \caption{Visit program.}
  \label{code:visit}
\end{figure}
\normalsize

If the graph is connected, it is easy to prove that every node \texttt{A} will derive \texttt{visited(A)},
regardless of the order in which rules are applied.
